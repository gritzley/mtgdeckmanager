// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using QuickType;
//
//    var welcome = Welcome.FromJson(jsonString);

namespace QuickType
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class CardSearchResult
    {
        [JsonProperty("cards")]
        public CardInfo[] Cards { get; set; }
    }

    public partial class CardInfo
    {
        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("manaCost")]
        public string ManaCost { get; set; }

        [JsonProperty("cmc")]
        public long Cmc { get; set; }

        [JsonProperty("colors")]
        public string[] Colors { get; set; }

        [JsonProperty("colorIdentity")]
        public string[] ColorIdentity { get; set; }

        [JsonProperty("type")]
        public string Type { get; set; }

        [JsonProperty("types")]
        public string[] Types { get; set; }

        [JsonProperty("subtypes", NullValueHandling = NullValueHandling.Ignore)]
        public string[] Subtypes { get; set; }

        [JsonProperty("rarity")]
        public string Rarity { get; set; }

        [JsonProperty("set")]
        public string Set { get; set; }

        [JsonProperty("setName")]
        public string SetName { get; set; }

        [JsonProperty("text", NullValueHandling = NullValueHandling.Ignore)]
        public string Text { get; set; }

        [JsonProperty("artist")]
        public string Artist { get; set; }

        [JsonProperty("number")]
        public string Number { get; set; }

        [JsonProperty("power", NullValueHandling = NullValueHandling.Ignore)]
        public string Power { get; set; }

        [JsonProperty("toughness", NullValueHandling = NullValueHandling.Ignore)]
        public string Toughness { get; set; }

        [JsonProperty("layout")]
        public string Layout { get; set; }

        [JsonProperty("multiverseid", NullValueHandling = NullValueHandling.Ignore)]
        public string Multiverseid { get; set; }

        [JsonProperty("imageUrl", NullValueHandling = NullValueHandling.Ignore)]
        public Uri ImageUrl { get; set; }

        [JsonProperty("variations", NullValueHandling = NullValueHandling.Ignore)]
        public Guid[] Variations { get; set; }

        [JsonProperty("foreignNames", NullValueHandling = NullValueHandling.Ignore)]
        public ForeignName[] ForeignNames { get; set; }

        [JsonProperty("printings")]
        public string[] Printings { get; set; }

        [JsonProperty("originalText", NullValueHandling = NullValueHandling.Ignore)]
        public string OriginalText { get; set; }

        [JsonProperty("originalType", NullValueHandling = NullValueHandling.Ignore)]
        public string OriginalType { get; set; }

        [JsonProperty("legalities")]
        public LegalityElement[] Legalities { get; set; }

        [JsonProperty("id")]
        public Guid Id { get; set; }

        [JsonProperty("flavor", NullValueHandling = NullValueHandling.Ignore)]
        public string Flavor { get; set; }

        [JsonProperty("rulings", NullValueHandling = NullValueHandling.Ignore)]
        public Ruling[] Rulings { get; set; }

        [JsonProperty("supertypes", NullValueHandling = NullValueHandling.Ignore)]
        public string[] Supertypes { get; set; }
    }

    public partial class ForeignName
    {
        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("text", NullValueHandling = NullValueHandling.Ignore)]
        public string Text { get; set; }

        [JsonProperty("type")]
        public string Type { get; set; }

        [JsonProperty("flavor")]
        public string Flavor { get; set; }

        [JsonProperty("imageUrl")]
        public Uri ImageUrl { get; set; }

        [JsonProperty("language")]
        public string Language { get; set; }

        [JsonProperty("multiverseid")]
        public string Multiverseid { get; set; }
    }

    public partial class LegalityElement
    {
        [JsonProperty("format")]
        public string Format { get; set; }

        [JsonProperty("legality")]
        public string Legality { get; set; }
    }

    public partial class Ruling
    {
        [JsonProperty("date")]
        public DateTimeOffset Date { get; set; }

        [JsonProperty("text")]
        public string Text { get; set; }
    }

    public enum ColorIdentity { B, U, W };

    public enum Color { Black, Blue, White };

    public enum Language { ChineseSimplified, French, German, Italian, Japanese, PortugueseBrazil, Russian, Spanish };

    public enum Layout { Normal };

    public enum Format { Brawl, Commander, Duel, Future, Gladiator, Historic, Legacy, Modern, Pauper, Penny, Pioneer, Premodern, Standard, Vintage };

    public enum LegalityEnum { Legal };

    public enum Rarity { Common, Rare, Uncommon };

    public enum Set { The10E };

    public enum SetName { TenthEdition };

    public enum TypeElement { Creature, Enchantment, Instant, Sorcery };

    public partial class Welcome
    {
        public static Welcome FromJson(string json) => JsonConvert.DeserializeObject<Welcome>(json, QuickType.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this Welcome self) => JsonConvert.SerializeObject(self, QuickType.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                ColorIdentityConverter.Singleton,
                ColorConverter.Singleton,
                LanguageConverter.Singleton,
                LayoutConverter.Singleton,
                FormatConverter.Singleton,
                LegalityEnumConverter.Singleton,
                RarityConverter.Singleton,
                SetConverter.Singleton,
                SetNameConverter.Singleton,
                TypeElementConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class ColorIdentityConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ColorIdentity) || t == typeof(ColorIdentity?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "B":
                    return ColorIdentity.B;
                case "U":
                    return ColorIdentity.U;
                case "W":
                    return ColorIdentity.W;
            }
            throw new Exception("Cannot unmarshal type ColorIdentity");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ColorIdentity)untypedValue;
            switch (value)
            {
                case ColorIdentity.B:
                    serializer.Serialize(writer, "B");
                    return;
                case ColorIdentity.U:
                    serializer.Serialize(writer, "U");
                    return;
                case ColorIdentity.W:
                    serializer.Serialize(writer, "W");
                    return;
            }
            throw new Exception("Cannot marshal type ColorIdentity");
        }

        public static readonly ColorIdentityConverter Singleton = new ColorIdentityConverter();
    }

    internal class ColorConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Color) || t == typeof(Color?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Black":
                    return Color.Black;
                case "Blue":
                    return Color.Blue;
                case "White":
                    return Color.White;
            }
            throw new Exception("Cannot unmarshal type Color");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Color)untypedValue;
            switch (value)
            {
                case Color.Black:
                    serializer.Serialize(writer, "Black");
                    return;
                case Color.Blue:
                    serializer.Serialize(writer, "Blue");
                    return;
                case Color.White:
                    serializer.Serialize(writer, "White");
                    return;
            }
            throw new Exception("Cannot marshal type Color");
        }

        public static readonly ColorConverter Singleton = new ColorConverter();
    }

    internal class LanguageConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Language) || t == typeof(Language?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Chinese Simplified":
                    return Language.ChineseSimplified;
                case "French":
                    return Language.French;
                case "German":
                    return Language.German;
                case "Italian":
                    return Language.Italian;
                case "Japanese":
                    return Language.Japanese;
                case "Portuguese (Brazil)":
                    return Language.PortugueseBrazil;
                case "Russian":
                    return Language.Russian;
                case "Spanish":
                    return Language.Spanish;
            }
            throw new Exception("Cannot unmarshal type Language");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Language)untypedValue;
            switch (value)
            {
                case Language.ChineseSimplified:
                    serializer.Serialize(writer, "Chinese Simplified");
                    return;
                case Language.French:
                    serializer.Serialize(writer, "French");
                    return;
                case Language.German:
                    serializer.Serialize(writer, "German");
                    return;
                case Language.Italian:
                    serializer.Serialize(writer, "Italian");
                    return;
                case Language.Japanese:
                    serializer.Serialize(writer, "Japanese");
                    return;
                case Language.PortugueseBrazil:
                    serializer.Serialize(writer, "Portuguese (Brazil)");
                    return;
                case Language.Russian:
                    serializer.Serialize(writer, "Russian");
                    return;
                case Language.Spanish:
                    serializer.Serialize(writer, "Spanish");
                    return;
            }
            throw new Exception("Cannot marshal type Language");
        }

        public static readonly LanguageConverter Singleton = new LanguageConverter();
    }

    internal class LayoutConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Layout) || t == typeof(Layout?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "normal")
            {
                return Layout.Normal;
            }
            throw new Exception("Cannot unmarshal type Layout");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Layout)untypedValue;
            if (value == Layout.Normal)
            {
                serializer.Serialize(writer, "normal");
                return;
            }
            throw new Exception("Cannot marshal type Layout");
        }

        public static readonly LayoutConverter Singleton = new LayoutConverter();
    }

    internal class FormatConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Format) || t == typeof(Format?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Brawl":
                    return Format.Brawl;
                case "Commander":
                    return Format.Commander;
                case "Duel":
                    return Format.Duel;
                case "Future":
                    return Format.Future;
                case "Gladiator":
                    return Format.Gladiator;
                case "Historic":
                    return Format.Historic;
                case "Legacy":
                    return Format.Legacy;
                case "Modern":
                    return Format.Modern;
                case "Pauper":
                    return Format.Pauper;
                case "Penny":
                    return Format.Penny;
                case "Pioneer":
                    return Format.Pioneer;
                case "Premodern":
                    return Format.Premodern;
                case "Standard":
                    return Format.Standard;
                case "Vintage":
                    return Format.Vintage;
            }
            throw new Exception("Cannot unmarshal type Format");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Format)untypedValue;
            switch (value)
            {
                case Format.Brawl:
                    serializer.Serialize(writer, "Brawl");
                    return;
                case Format.Commander:
                    serializer.Serialize(writer, "Commander");
                    return;
                case Format.Duel:
                    serializer.Serialize(writer, "Duel");
                    return;
                case Format.Future:
                    serializer.Serialize(writer, "Future");
                    return;
                case Format.Gladiator:
                    serializer.Serialize(writer, "Gladiator");
                    return;
                case Format.Historic:
                    serializer.Serialize(writer, "Historic");
                    return;
                case Format.Legacy:
                    serializer.Serialize(writer, "Legacy");
                    return;
                case Format.Modern:
                    serializer.Serialize(writer, "Modern");
                    return;
                case Format.Pauper:
                    serializer.Serialize(writer, "Pauper");
                    return;
                case Format.Penny:
                    serializer.Serialize(writer, "Penny");
                    return;
                case Format.Pioneer:
                    serializer.Serialize(writer, "Pioneer");
                    return;
                case Format.Premodern:
                    serializer.Serialize(writer, "Premodern");
                    return;
                case Format.Standard:
                    serializer.Serialize(writer, "Standard");
                    return;
                case Format.Vintage:
                    serializer.Serialize(writer, "Vintage");
                    return;
            }
            throw new Exception("Cannot marshal type Format");
        }

        public static readonly FormatConverter Singleton = new FormatConverter();
    }

    internal class LegalityEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(LegalityEnum) || t == typeof(LegalityEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "Legal")
            {
                return LegalityEnum.Legal;
            }
            throw new Exception("Cannot unmarshal type LegalityEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (LegalityEnum)untypedValue;
            if (value == LegalityEnum.Legal)
            {
                serializer.Serialize(writer, "Legal");
                return;
            }
            throw new Exception("Cannot marshal type LegalityEnum");
        }

        public static readonly LegalityEnumConverter Singleton = new LegalityEnumConverter();
    }

    internal class ParseStringConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(long) || t == typeof(long?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            long l;
            if (Int64.TryParse(value, out l))
            {
                return l;
            }
            throw new Exception("Cannot unmarshal type long");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (long)untypedValue;
            serializer.Serialize(writer, value.ToString());
            return;
        }

        public static readonly ParseStringConverter Singleton = new ParseStringConverter();
    }

    internal class RarityConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Rarity) || t == typeof(Rarity?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Common":
                    return Rarity.Common;
                case "Rare":
                    return Rarity.Rare;
                case "Uncommon":
                    return Rarity.Uncommon;
            }
            throw new Exception("Cannot unmarshal type Rarity");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Rarity)untypedValue;
            switch (value)
            {
                case Rarity.Common:
                    serializer.Serialize(writer, "Common");
                    return;
                case Rarity.Rare:
                    serializer.Serialize(writer, "Rare");
                    return;
                case Rarity.Uncommon:
                    serializer.Serialize(writer, "Uncommon");
                    return;
            }
            throw new Exception("Cannot marshal type Rarity");
        }

        public static readonly RarityConverter Singleton = new RarityConverter();
    }

    internal class SetConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Set) || t == typeof(Set?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "10E")
            {
                return Set.The10E;
            }
            throw new Exception("Cannot unmarshal type Set");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Set)untypedValue;
            if (value == Set.The10E)
            {
                serializer.Serialize(writer, "10E");
                return;
            }
            throw new Exception("Cannot marshal type Set");
        }

        public static readonly SetConverter Singleton = new SetConverter();
    }

    internal class SetNameConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(SetName) || t == typeof(SetName?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "Tenth Edition")
            {
                return SetName.TenthEdition;
            }
            throw new Exception("Cannot unmarshal type SetName");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (SetName)untypedValue;
            if (value == SetName.TenthEdition)
            {
                serializer.Serialize(writer, "Tenth Edition");
                return;
            }
            throw new Exception("Cannot marshal type SetName");
        }

        public static readonly SetNameConverter Singleton = new SetNameConverter();
    }

    internal class TypeElementConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TypeElement) || t == typeof(TypeElement?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Creature":
                    return TypeElement.Creature;
                case "Enchantment":
                    return TypeElement.Enchantment;
                case "Instant":
                    return TypeElement.Instant;
                case "Sorcery":
                    return TypeElement.Sorcery;
            }
            throw new Exception("Cannot unmarshal type TypeElement");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TypeElement)untypedValue;
            switch (value)
            {
                case TypeElement.Creature:
                    serializer.Serialize(writer, "Creature");
                    return;
                case TypeElement.Enchantment:
                    serializer.Serialize(writer, "Enchantment");
                    return;
                case TypeElement.Instant:
                    serializer.Serialize(writer, "Instant");
                    return;
                case TypeElement.Sorcery:
                    serializer.Serialize(writer, "Sorcery");
                    return;
            }
            throw new Exception("Cannot marshal type TypeElement");
        }

        public static readonly TypeElementConverter Singleton = new TypeElementConverter();
    }
}
